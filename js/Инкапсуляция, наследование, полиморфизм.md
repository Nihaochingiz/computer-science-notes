# ООП в JavaScript: наследование, инкапсуляция, полиморфизм

JavaScript реализует основные принципы объектно-ориентированного программирования (ООП), хотя и делает это несколько иначе, чем классические ООП-языки. Рассмотрим три ключевых концепции:

## 1. Наследование (Inheritance)

В JavaScript используется **прототипное наследование**, которое отличается от классического классового. Синтаксис классов ES6 — это "синтаксический сахар" над прототипами.

### Реализация наследования:

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    console.log(`${this.name} издает звук.`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // вызов конструктора родителя
    this.breed = breed;
  }
  
  speak() {
    console.log(`${this.name} лает!`);
  }
  
  fetch() {
    console.log(`${this.name} принес мяч!`);
  }
}

const dog = new Dog('Рекс', 'Овчарка');
dog.speak(); // Рекс лает!
dog.fetch(); // Рекс принес мяч!
```

### Особенности:
- Ключевое слово `extends` для наследования
- `super()` — вызов конструктора родителя (обязателен в дочернем конструкторе)
- `super.method()` — вызов метода родителя
- Можно наследовать от встроенных классов (Array, Error и др.)

## 2. Инкапсуляция (Encapsulation)

Инкапсуляция — это сокрытие внутренней реализации и защита данных. В JavaScript (особенно до ES2022) она реализуется условно.

### Способы инкапсуляции:

#### Приватные поля (ES2022+):
```javascript
class BankAccount {
  #balance = 0; // приватное поле
  
  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
    }
  }
  
  get balance() {
    return this.#balance;
  }
}

const account = new BankAccount();
account.deposit(100);
console.log(account.balance); // 100
console.log(account.#balance); // Ошибка: Private field must be declared in an enclosing class
```

#### Замыкания (до ES2022):
```javascript
function createCounter() {
  let count = 0; // "приватная" переменная
  
  return {
    increment() {
      count++;
    },
    get value() {
      return count;
    }
  };
}

const counter = createCounter();
counter.increment();
console.log(counter.value); // 1
console.log(counter.count); // undefined
```

## 3. Полиморфизм (Polymorphism)

Полиморфизм позволяет объектам разных типов реагировать на одни и те же методы по-разному.

### Пример полиморфизма:

```javascript
class Shape {
  area() {
    return 0;
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }
  
  area() {
    return Math.PI * this.radius ** 2;
  }
}

class Square extends Shape {
  constructor(side) {
    super();
    this.side = side;
  }
  
  area() {
    return this.side ** 2;
  }
}

const shapes = [new Circle(5), new Square(4)];

shapes.forEach(shape => {
  console.log(`Area: ${shape.area()}`);
  // Area: 78.53981633974483
  // Area: 16
});
```

### Особенности полиморфизма в JS:
- Утиная типизация: "Если что-то выглядит как утка и крякает как утка, то это утка"
- Переопределение методов в дочерних классах
- Возможность вызывать методы родителя через `super`

## Итоговый пример всех принципов:

```javascript
class Employee {
  #salary; // инкапсуляция
  
  constructor(name, position, salary) {
    this.name = name;
    this.position = position;
    this.#salary = salary;
  }
  
  get salary() {
    return this.#salary;
  }
  
  work() {
    console.log(`${this.name} выполняет свои обязанности`);
  }
}

class Developer extends Employee { // наследование
  constructor(name, salary, language) {
    super(name, 'Developer', salary);
    this.language = language;
  }
  
  work() { // полиморфизм
    console.log(`${this.name} пишет код на ${this.language}`);
  }
  
  debug() {
    console.log(`${this.name} ищет баги...`);
  }
}

const dev = new Developer('Алексей', 100000, 'JavaScript');
dev.work(); // Алексей пишет код на JavaScript
console.log(dev.salary); // 100000 (через геттер)
dev.debug(); // Алексей ищет баги...
```

JavaScript поддерживает все три принципа ООП, хотя и делает это с некоторыми особенностями, обусловленными его прототипной природой. Современные версии ES (особенно ES6+) значительно улучшили читаемость и удобство ООП в JS.